*exif_read_data*

(PHP 4 >= 4.2.0, PHP 5, PHP 7, PHP 8)

exif_read_data — Reads the EXIF headers from an image file

===============================================================================
[ Description ]

  exif_read_data(    resource|string~
  $file,    ?string $required_sections =~
  null,    bool $as_arrays =~
  false,    bool $read_thumbnail = false): array|false~

exif_read_data() reads the EXIF headers from an image file. This way you can
read meta data generated by digital cameras.

EXIF headers tend to be present in JPEG/TIFF images generated by digital
cameras, but unfortunately each digital camera maker has a different idea of
how to actually tag their images, so you can't always rely on a specific Exif
header being present.

Height and Width are computed the same way |getimagesize| does so their values
must not be part of any header returned. Also, html is a height/width text
string to be used inside normal HTML.

When an Exif header contains a Copyright note, this itself can contain two
values. As the solution is inconsistent in the Exif 2.10 standard, the COMPUTED
section will return both entries Copyright.Photographer and Copyright.Editor
while the IFD0 sections contains the byte array with the NULL character that
splits both entries. Or just the first entry if the datatype was wrong (normal
behaviour of Exif). The COMPUTED will also contain the entry Copyright which is
either the original copyright string, or a comma separated list of the photo
and editor copyright.

The tag UserComment has the same problem as the Copyright tag. It can store two
values. First the encoding used, and second the value itself. If so the IFD
section only contains the encoding or a byte array. The COMPUTED section will
store both in the entries UserCommentEncoding and UserComment. The entry
UserComment is available in both cases so it should be used in preference to
the value in IFD0 section.

exif_read_data() also validates EXIF data tags according to the EXIF
specification (» http://exif.org/Exif2-2.PDF, page 20).

===============================================================================
[ Parameters ]

{file}

  The location of the image file. This can either be a path to the file (stream
  wrappers are also supported as usual) or a stream resource.

{required_sections}

  Is a comma separated list of sections that need to be present in file to
  produce a result array. If none of the requested sections could be found the
  return value is false.

  FILE      FileName, FileSize, FileDateTime, SectionsFound
            html, Width, Height, IsColor, and more if available. Height and
  COMPUTED  Width are computed the same way |getimagesize| does so their values
            must not be part of any header returned. Also, html is a height/
            width text string to be used inside normal HTML.
  ANY_TAG   Any information that has a Tag e.g. IFD0, EXIF, ...
  IFD0      All tagged data of IFD0. In normal imagefiles this contains image
            size and so forth.
            A file is supposed to contain a thumbnail if it has a second IFD.
  THUMBNAIL All tagged information about the embedded thumbnail is stored in
            this section.
  COMMENT   Comment headers of JPEG images.
            The EXIF section is a sub section of IFD0. It contains more
  EXIF      detailed information about an image. Most of these entries are
            digital camera related.

{as_arrays}

  Specifies whether or not each section becomes an array. The
  {required_sections} COMPUTED, THUMBNAIL, and COMMENT always become arrays as
  they may contain values whose names conflict with other sections.

{read_thumbnail}

  When set to true the thumbnail itself is read. Otherwise, only the tagged
  data is read.

===============================================================================
[ Return Values ]

It returns an associative array where the array indexes are the header names
and the array values are the values associated with those headers. If no data
can be returned, exif_read_data() will return false.

===============================================================================
[ Errors/Exceptions ]

Errors of level E_WARNING and/or E_NOTICE may be raised for unsupported tags or
other potential error conditions, but the function still tries to read all
comprehensible information.

===============================================================================
[ Changelog ]

Version                               Description
8.0.0   {required_sections} is nullable now.
7.2.0   The {file} parameter now supports both local files and stream
        resources.
        Support for the following EXIF formats were added:

         * Samsung
         * DJI
         * Panasonic
         * Sony
7.2.0    * Pentax
         * Minolta
         * Sigma/Foveon
         * AGFA
         * Kyocera
         * Ricoh
         * Epson

===============================================================================
[ Examples ]

Example #1 exif_read_data() example

<?php >
  echo "test1.jpg:<br />\n";
  $exif = exif_read_data('tests/test1.jpg', 'IFD0');
  echo $exif===false ? "No header data found.<br />\n" : "Image contains headers
  <br />\n";

  $exif = exif_read_data('tests/test2.jpg', 0, true);
  echo "test2.jpg:<br />\n";
  foreach ($exif as $key => $section) {
  foreach ($section as $name => $val) {
  echo "$key.$name: $val<br />\n";
  }
  }
<?>

The first call fails because the image has no header information.

The above example will output something similar to:

test1.jpg:
No header data found.
test2.jpg:
FILE.FileName: test2.jpg
FILE.FileDateTime: 1017666176
FILE.FileSize: 1240
FILE.FileType: 2
FILE.SectionsFound: ANY_TAG, IFD0, THUMBNAIL, COMMENT
COMPUTED.html: width="1" height="1"
COMPUTED.Height: 1
COMPUTED.Width: 1
COMPUTED.IsColor: 1
COMPUTED.ByteOrderMotorola: 1
COMPUTED.UserComment: Exif test image.
COMPUTED.UserCommentEncoding: ASCII
COMPUTED.Copyright: Photo (c) M.Boerger, Edited by M.Boerger.
COMPUTED.Copyright.Photographer: Photo (c) M.Boerger
COMPUTED.Copyright.Editor: Edited by M.Boerger.
IFD0.Copyright: Photo (c) M.Boerger
IFD0.UserComment: ASCII
THUMBNAIL.JPEGInterchangeFormat: 134
THUMBNAIL.JPEGInterchangeFormatLength: 523
COMMENT.0: Comment #1.
COMMENT.1: Comment #2.
COMMENT.2: Comment #3end
THUMBNAIL.JPEGInterchangeFormat: 134
THUMBNAIL.Thumbnail.Height: 1
THUMBNAIL.Thumbnail.Height: 1

Example #2 exif_read_data() with streams available as of PHP 7.2.0

<?php >
  // Open a the file, this should be in binary mode
  $fp = fopen('/path/to/image.jpg', 'rb');

  if (!$fp) {
  echo 'Error: Unable to open image for reading';
  exit;
  }

  // Attempt to read the exif headers
  $headers = exif_read_data($fp);

  if (!$headers) {
  echo 'Error: Unable to read exif headers';
  exit;
  }

  // Print the 'COMPUTED' headers
  echo 'EXIF Headers:' . PHP_EOL;

  foreach ($headers['COMPUTED'] as $header => $value) {
  printf(' %s => %s%s', $header, $value, PHP_EOL);
  }
<?>

The above example will output something similar to:

EXIF Headers:
 Height => 576
 Width => 1024
 IsColor => 1
 ByteOrderMotorola => 0
 ApertureFNumber => f/5.6
 UserComment =>
 UserCommentEncoding => UNDEFINED
 Copyright => Denis
 Thumbnail.FileType => 2
 Thumbnail.MimeType => image/jpeg

===============================================================================
[ Notes ]

  Note:

  If mbstring is enabled, exif will attempt to process the unicode and pick a
  charset as specified by exif.decode_unicode_motorola and
  exif.decode_unicode_intel. The exif extension will not attempt to figure out
  the encoding on its own, and it is up to the user to properly specify the
  encoding for which to use for decoding by setting one of these two ini
  directives prior to calling exif_read_data().

  Note:

  If the {file} is used to pass a stream to this function, then the stream must
  be seekable. Note that the file pointer position is not changed after this
  function returns.

===============================================================================
[ See Also ]

 * |exif_thumbnail| - Retrieve the embedded thumbnail of an image
 * |getimagesize| - Get the size of an image
 * Supported Protocols and Wrappers


vim:ft=help: